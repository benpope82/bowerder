{"version":3,"sources":["loader.js"],"names":["bower","components","Object","window","console","warn","dir","devMode","loadingCount","total","callbacks","packagesTree","browser","loaded","regTag","undefined","loaderTag","waitingCB","waitingImport","status","error","fromBrowser","fromBowerder","xhrGet","path","isAsync","callback","String","Boolean","Function","xhr","XMLHttpRequest","overrideMimeType","ActiveXObject","e1","e2","message","open","send","onreadystatechange","response","readyState","text","responseText","statusText","packageIndex","pkgName","i","name","checkCallback","counter","main","length","forEach","ready","push","cbIndex","attachPackageCB","node","Element","attachEvent","toString","indexOf","isOpera","addEventListener","errorFrom","parseTagType","targetFile","tag","type","fext","slice","Math","max","lastIndexOf","Infinity","test","rel","addPackage","pkgCaller","loadPackageConfig","pkgConfig","async","splice","pkgDeps","getOwnPropertyNames","checkReadyToImport","j","pkgScriptTags","pkgLinkTags","isAlreadyLoaded","opera","domLoaderTags","devLinkTag","devScriptTag","getTag","pkg","document","querySelector","head","call","getElementsByTagName","concat","getAttribute","index","createElement","setAttribute","src","href","insertBefore","appendChild","log","Number","isAlreadyOk","reponse","JSON","parse","domScriptTags","onload","pkgInfo","onerror"],"mappings":"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","file":"loader.min.js","sourcesContent":["/* bower component loader for the browser\n ________________________________________________________________________________________\n *\n * Easly Import your components or libraries installed via bower to your project.\n * \n * @license MIT\n * @author  [Tindo Ngoufo Arsel](mailto:devtnga@gmail.com)\n*/\n\n// manage possible conflict with loader namespace definition.\nif (typeof bower !== 'undefined' && !(bower.components instanceof Object)) {\n\n   console.warn('Seem like `bower` namespace is use for another purpose. Taking risk of an overwrite ...');\n   window.bower = bower = {};\n   console.warn('Forcing `bower` namespace initialization ... done.');\n\n} else if (typeof bower === 'undefined') {\n\n   window.bower = {};\n}\n\n/* importing package is an interresting hack when we have to avoid duplicate import and manage dependencies.\n * the method here is to have a registry where we will add package's configuration in particular order (function of dependency or not).\n * package's configuration is an object build from `bower.json` assciated file.\n * dependencies will always be imported before package of which depends; this influences how order is done in packages's configuration registry.\n * package have to have a unique occurrence on the registry; this assure that we will not have duplicate component's import.\n * that particular registry is the *dependencies package's tree registry*.\n * there will be also a main registry which is the *local packages's registry*, that will content all project's components's configurations installed via bower.\n * there will be therefore a provided command line tools (`bowerder`) that will help developer to generate the considered *local packages's registry* for a target project.\n * if the loader can't use any associated *local packages's registry* to import packages, it will try to use Ajax API to resolve the operation.\n * bower components directory have to be provided to loader so that it can know where to find packages main files. (this can be done through the global `dir` property)\n * however setting a `data-bowerreg` attribute to bowerder's script tag will be sufficient to it for determination of some needed like `bower components directory`.\n * \n * with each import instruction, can be associated a callback function.\n * considered callback is executed when associated package's importation is fully done.\n * package's importation is fully done when all it main files and it dependencies main files (if defined) are loaded *in the DOM*.\n * a callback take an object as argument with the following properties:\n * `error` : a boolean which inform if the associated package's importation was fully done or not;\n * `errorFrom` : a string which inform about the place where the error occured, possible value are \"browser\" or \"bowerder\";\n *    if the value is \"bowerder\" it's maybe an internal/connection error when loading package configuration (bower.json),\n *    if the value is \"browser\" it's maybe a 404/connection error on loading main files *in the DOM*;\n *    therefore, console is the place to see what really happen.\n * that object is usefull to check if there isn't an error (conditions are good) for some instructions.\n * in case of contionnal or timed importation, if a package is already fully imported or have already adressed a full loading process, the associated callback will be immediatly executed.\n * this is to introduce the fact that many callbacks can be associated to a package's importation via multiple `import's` instructions.\n * that said there will be a registry where we can acces to any package's associated callbacks, via the package's name.\n * \n * for some globals tasks, global callbacks can be managed through the special bowerder \"reserved\" package's named `#bowerder`.\n * global callback take an object as argument with the following properties:\n * `error` : a boolean which inform if all package's importation was fully done or not;\n * `errorBrowser` : an array which inform about packages where error occured and if it was from \"browser\" loading operations;\n * `errorBowerder` : an array which inform about packages where error occured and if it was from \"bowerder\" loading operations;\n *    therefore, console is the place to see what really happen.\n *    \n * to better manage some stuff, the loader can set extras porperties through the `browser` object, which will be itself a property of the package's configuration object. \n*/\n\nbower.dir = './bower_components';      // bower base directory\nbower.devMode = false;      // bower base directory\nbower.loadingCount = 0;   // number of package that are in loading process\nbower.total = 0;          // total number of packages that must to be loaded\nbower.callbacks = {};     // packages's callback functions registry \nbower.packagesTree = [];  // packages's configuration registry\n\nbower.browser = {          // these properties will help in some case for bowerder global processing.\n   loaded: false,\n   regTag: undefined,    // reference to *local packages's registry* script tag\n   loaderTag: undefined, // reference to bowerder's script tag\n   waitingCB: [],         // index of callbacks's to be execute after full packages's importation \"in the DOM\" \n   waitingImport: [],     // for package that will wait for *local packages's registry* state, before to be imported\n   status: {error: false, fromBrowser: [], fromBowerder: []},\n};\n\n\n/**\n * get the text reponse through an ajax request from a given path\n * @param   {string}   path     path where to get file's content\n * @param   {boolean}  isAsync  enable request asynchrone or not\n * @param   {function} callback the function to execute after the end of request process. take the returned object as argument \n * @returns {object}   content the answer informations with this properties {error: boolean, status: number, statusText: string, text: string}\n */\nbower.xhrGet = function (path, isAsync, callback) {\n\n   if (typeof path !== 'string' && !(path instanceof String)) {\n\n      console.error('bowerder: path must be give as a string');\n      return null;\n   }\n\n   isAsync = (typeof isAsync === 'boolean' || isAsync instanceof Boolean) ? isAsync : true;\n   callback = (typeof callback === 'function' || callback instanceof Function) ? callback : undefined;\n\n   var xhr = undefined;\n\n   if (window.XMLHttpRequest) {\n\n      xhr = new XMLHttpRequest(); // For Chrome, Firefox, Opera and others...\n\n      if (xhr.overrideMimeType)\n         xhr.overrideMimeType('text/xml'); // Avoid Safari’s bug\n   }\n   else if (window.ActiveXObject) {\n      // For Internet Explorer\n      try {\n         xhr = new ActiveXObject('Msxml2.XMLHTTP');  \n      } catch (e1) {\n         try {\n            xhr = new ActiveXObject('Microsoft.XMLHTTP');  \n         } catch (e2) {\n            console.warn( e1.message );\n            console.warn( e2.message );\n         }\n      }\n   }\n\n   if (!(xhr instanceof Object)) {\n\n      console.error(\"bowerder: Can’t init Ajax functionalities. Maybe it’s your browser version ?\");\n      return null;\n   }\n\n   // on soumet les champs de connexion à la page de traitement approprié pour vérification\n   xhr.open('GET', path, true);\n   // xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n   // Si la requêtte s'est exécutée sans erreur on recupère le resultat du traitement\n   xhr.send();\n\n   xhr.onreadystatechange = function() {\n\n      var response = {};\n      response.error = false;\n\n      if(xhr.readyState == 4 && xhr.status == 200) {\n\n         response.status = xhr.status;\n         response.text = xhr.responseText;\n\n         if (callback) callback( response );\n\n         return response;\n      } \n      else if (xhr.readyState == 4 && xhr.status != 200) {\n\n         response.status = xhr.status;\n         response.statusText = xhr.statusText;\n         response.error = true;\n         console.error('bowerder: Ajax request error (status: '+ xhr.status +'), try to check your connection. ');\n\n         if (callback) callback( response );\n\n         return response;\n      }\n   }  \n};\n\n/**\n * helpfull to determine if a package is in the packages's configuration registry\n * @param   {string} pkgName the name of the package\n * @returns {number} index of the first occurrence of the given package. -1 if it's isn't in the registry.\n */\nbower.packageIndex = function (pkgName) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error('bowerder:packageIndex: argument must be a string' );\n   }\n   else {\n\n      for (i in bower.packagesTree) {\n\n         if (bower.packagesTree[i].name === pkgName) return i;\n      }\n   }\n\n   return -1;\n};\n\n/**\n * helpfull to get a package's configuration from the registry\n * @param   {string} pkgName the name of the package\n * @returns {object} the first occurrence of the given package. undefined if it's isn't in the registry.\n */\nbower.package = function (pkgName) {\n\n   return bower.packagesTree[ bower.packageIndex( pkgName ) ];\n};\n\n/**\n * check the correct moment to execute callbacks associated to a package and do it.\n * @param {string} pkgName the name of a package\n */\nbower.checkCallback = function (pkgName) {\n\n   /* the hack here is to be sure that all associated main files of considered package are loaded in the browser.\n    * this is checked with a counter which content the number of main files that was loaded (event if the loading fail with browser loading process).\n    * therefore the package is fully imported when the counter is equal to total of the package's main files.\n    * callback is executed only if the package is fully imported.\n   */\n   if (!bower.package( pkgName ).browser.loaded) bower.package( pkgName ).browser.counter++;\n\n   if (bower.package( pkgName ).browser.counter === bower.package( pkgName ).browser.main.length) {\n\n      bower.package( pkgName ).browser.loaded = true; \n\n      if (bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ].forEach( function (callback) {\n\n            callback( bower.package( pkgName ).browser.status );\n         });\n      }\n\n      //will check if all packages are fully imported for global callbacks's executions\n      bower.ready(); \n   }\n}\n\n/**\n * usefull to run callbacks after full packages's importation \"in the DOM\".\n * @param {function} callback function to execute. If empty, the function will try to run waiting callbacks.\n */\nbower.ready = function (callback) {\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:ready: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks['#bowerder']) bower.callbacks['#bowerder'] = [];\n\n         bower.callbacks['#bowerder'].push( callback );\n\n         /* with current ready's process, callback which is added to the callbacks's registry have the last index for the associated package,\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions\n         */\n         bower.browser.waitingCB.push( bower.callbacks['#bowerder'].length - 1 );\n      }\n   }\n\n   if (bower.packagesTree.length > 0) bower.browser.loaded = true;\n\n   for (var i=0; i<bower.packagesTree.length; i++) {\n\n      if (!bower.packagesTree[i].browser.loaded) {\n\n         bower.browser.loaded = false;\n         break;\n      }\n   }\n\n   if (bower.browser.loaded) {\n\n      bower.browser.waitingCB.forEach( function (cbIndex) {\n\n         bower.callbacks['#bowerder'][cbIndex]( bower.browser.status );\n      });\n   }\n};  \n\n/**\n * attach considered package's callbacks to it main files browser `load` event\n * @param   {Element}  node    element to attach callbacks on it `load` event\n * @param   {string}   pkgName package's name to use associated callbacks\n*/\nbower.attachPackageCB = function (node, pkgName) {\n\n   if (!(node instanceof Element)) {\n\n      console.warn('bowerder:attachPackageCB: argument must be an Element');\n      return null;\n   }\n\n   // Set up load listener. Test attachEvent first because IE9 has\n   // a subtle issue in its addEventListener and script onload firings\n   // that do not match the behavior of all other browsers with\n   // addEventListener support, which fire the onload event for a\n   // script right after the script execution. See:\n   // https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n   // UNFORTUNATELY Opera implements attachEvent but does not follow the script\n   // script execution mode.\n   if (node.attachEvent &&\n       // Check if node.attachEvent is artificially added by custom script or\n       // natively supported by browser\n       // read https://github.com/requirejs/requirejs/issues/187\n       // if we can NOT find [native code] then it must NOT natively supported.\n       // in IE8, node.attachEvent does not have toString()\n       // Note the test for \"[native code\" with no closing brace, see:\n       // https://github.com/requirejs/requirejs/issues/273\n       !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n       !isOpera) {\n      // Probably IE. IE (at least 6-8) do not fire\n      // script onload right after executing the script, so\n      // we cannot tie the anonymous define call to a name.\n      // However, IE reports the script as being in 'interactive'\n      // readyState at the time of the define call.\n\n      node.attachEvent('onreadystatechange', function () { bower.checkCallback( pkgName ); });\n      // It would be great to add an error handler here to catch\n      // 404s in IE9+. However, onreadystatechange will fire before\n      // the error handler, so that does not help. If addEventListener\n      // is used, then IE will fire error before load, but we cannot\n      // use that pathway given the connect.microsoft.com issue\n      // mentioned above about not doing the 'script execute,\n      // then fire the script load event listener before execute\n      // next script' that other browsers do.\n      // Best hope: IE10 fixes the issues,\n      // and then destroys all installs of IE 6-9.\n      // node.attachEvent('onerror', context.onScriptError);\n   } else {\n\n      node.addEventListener('load', function () { bower.checkCallback( pkgName ); }, false);\n      node.addEventListener('error', function () { \n\n         bower.package( pkgName ).browser.status = {error: true, errorFrom: 'browser'};\n         bower.browser.status.error = true;\n         bower.browser.status.fromBrowser.push( pkgName );\n\n         bower.checkCallback( pkgName ); \n      }, false );\n   }\n}\n\n/**\n * helpfull to determine which html tag have to be used to import a component in the DOM\n * @param   {string} targetFile component's file to include\n * @returns {object} an object that contains informations about html tag to use\n */\nbower.parseTagType = function (targetFile) {\n\n   if (typeof targetFile !== 'string' && !(targetFile instanceof String)) {\n\n      console.error('bowerder:parseTagType: argument must be a string' );\n      targetFile = \"\";\n   }\n\n   var tag = {name: 'unknow', type: 'unknow'};\n   // get the target file extension\n   tag.fext = targetFile.slice((Math.max(0, targetFile.lastIndexOf('.')) || Infinity) + 1);\n\n   if (tag.fext === 'js') { // it's a js like file\n\n      tag.name = 'script';\n      tag.type = 'text/javascript';        \n   }\n   if (tag.fext === 'css' || tag.fext ==='scss' || tag.fext ==='sass' || tag.fext ==='less') { // it's a css like\n\n      tag.name = 'link';\n      tag.type = 'text/css';\n\n      if (/\\.css$/.test( targetFile )) tag.rel = 'stylesheet';\n      else tag.rel = 'stylesheet/'+ tag.fext;            \n   }\n   if (tag.fext === 'txt') { // it's a plain text like file\n\n      tag.name = 'link';\n      tag.type = 'text/plain';        \n      tag.rel = 'alternate';\n      // @TODO set the tag.title with the name of the targetFile (regex must be usefull here)\n   }\n\n   return tag;\n};\n\n/**\n * organize packages's tree dependencies, process their importation \"in the DOM\" with asssociated callback if available\n * @param   {string}   pkgName   package's name\n * @param   {string}   pkgCaller package's of package which depends of first (argument) given package. usefull for dependencies management.\n * @param   {number}   cbIndex   index of current associated callback in callbacks's registry (if given)\n */\nbower.addPackage = function (pkgName, pkgCaller, cbIndex) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error(\"bowerder:addPackage: package's name must be a string\");\n      return null;\n   }\n   if (pkgCaller && (typeof pkgCaller !== 'string') && !(pkgCaller instanceof String)) console.warn(\"bowerder:addPackage: package caller's name must be a string\");\n   if (cbIndex && (typeof cbIndex !== 'number') && !(cbIndex instanceof Number)) console.warn(\"bowerder:addPackage: callback index must be a number\");\n\n   var isAlreadyOk = false;\n\n   /* check if package to load is already present in the registry.\n    * if it's a dependency, check if it's present in the registry before package of which depends.\n    * if so, nothing will be done, else the adding operation to the registry will be process.\n   */\n   if (bower.package( pkgName )) {\n\n      isAlreadyOk = true;\n\n      // if the package is already fully loaded *in the DOM*, the current associated callback is executed.\n      if (cbIndex && bower.package( pkgName ).browser.loaded && bower.callbacks[ pkgName ]) {\n\n         bower.callbacks[ pkgName ][cbIndex]( bower.package( pkgName ).browser.status );\n      }\n\n      if (pkgCaller && (bower.packageIndex( pkgCaller ) != -1) ) {\n         /* major browsers load and execute script included by another script asynchronously.\n          * the problem here is that, package which have dependencies have to be execute after them.\n          * therefore, for these package, it's primordial to load them synchronously.\n         */\n         bower.package( pkgName ).browser.async = false;\n         bower.package( pkgCaller ).browser.async = false;\n\n         if (bower.packageIndex( pkgCaller ) < bower.packageIndex( pkgName )) isAlreadyOk = false;\n      }\n   }\n\n   if (!isAlreadyOk) { // process the adding operation to the registry.\n\n      bower.loadingCount++;\n      bower.total++;\n\n      if ((bower.components instanceof Object) && bower.components[ pkgName ]) {\n\n         var pkgConfig = bower.components[ pkgName ];\n         /* for reason due to size some properties in `bower.json` have been deleted with provided local registry (using bowerder on command line).\n          * `name` is one of them, and the reason of it was removed was to avoid duplication since as once can see, package's configuration is accessible with package's name.\n          * this is valable for `bower.components` (local registry), but not for `bower.packagesTree` (import registry), which need that `name` property to be set.\n         */\n         pkgConfig.name = pkgName;\n\n         loadPackageConfig( pkgConfig );\n\n         checkReadyToImport();\n      }\n      else {\n\n         if ((bower.components instanceof Object) && !bower.components[ pkgName ]) {\n\n            console.warn(\"bowerder:addPackage: can't found `\"+ pkgName +\"` in project's local registry; will try to import package through Ajax API.\");\n         }\n\n         bower.xhrGet( bower.dir +'/'+ pkgName +'/bower.json', true, function (reponse) {\n\n            if (reponse.error) {\n\n               console.error('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n\n               /* considering that the package will not be imported and\n                * then will not be added to the packages's configuration registry,\n                * associated callback functions are executed with status error from bowerder.\n               */\n               if ((typeof cbIndex === 'number' || cbIndex instanceof Number) && bower.callbacks[ pkgName ]) {\n\n                  bower.callbacks[ pkgName ][cbIndex]( {error: true, errorFrom: 'bowerder'} );\n               } \n\n               bower.browser.status.error = true;\n               bower.browser.status.fromBowerder.push( pkgName );                \n            }\n            else {\n\n               var pkgConfig = JSON.parse( reponse.text ); \n\n               if (pkgConfig instanceof Object) {\n\n                  delete pkgConfig['ignore'];\n                  delete pkgConfig['keywords'];\n                  delete pkgConfig['moduleType'];\n                  delete pkgConfig['resolutions'];\n\n                  loadPackageConfig( pkgConfig );\n               }\n               else {\n\n                  console.warn('bowerder:addPackage: unable to load `'+ pkgName +'` component.' );\n               }\n            } \n\n            checkReadyToImport();\n         });\n      }\n\n      /**\n       * register package's configuration with it dependencies (if defined) in the packages's tree registry.\n       * @param {object} pkgConfig package's configuration from it `bower.json`\n       * @private\n      */\n      function loadPackageConfig (pkgConfig) {\n\n         if (!(pkgConfig.browser instanceof Object)) pkgConfig.browser = {};\n         // by default,load and execute script asynchronously\n         pkgConfig.browser.async = true;\n         // by default, files to load from the package aren't yet imported\n         pkgConfig.browser.loaded = false;\n         // by default, set importation status to done without error  \n         pkgConfig.browser.status = {error: false, errorFrom: undefined};\n         // init the number of imported file counter for the package\n         pkgConfig.browser.counter = 0;\n\n         /* minification is a way for developper to have for some files a better loading optimization. \n          * however, `bower.json` spec do not allow to use minified files as mains files for a component.\n          * developers use to set associated `main` property with sources or developments files.\n          * considering how web projects are now build, that pratice isn't advantageous for browsers.\n          * indeed, set an `index.scss` or an unminified `index.js` file as main file isn't good for browsers to digest.\n          * that why is now recommended to also set a `browser: {main: []}` properties for mains files that browsers can easly digest.\n          * minified files with sourcemaps are specialy welcome in that case.\n          * bowerder will use that properties to load component *in the DOM*; if they aren't set, it will use the `main` property. \n          * here is an example illustration for bowerder to well do it job:\n          * // bower.json\n          *    main: [\"dist/index.scss\", \"dist/index.coffee\"], // keep bower json spec\n          *    browser: {\n          *       main: [\"dist/index.min.css\", \"dist/index.min.js\"] // for browsers through bowerder\n          *    }\n          *    ... // others properties\n         */\n         if (!pkgConfig.browser.main) {\n\n            if (!pkgConfig.main) {\n\n               console.warn(\"bowerder:addPackage: there isn't main files indication for \"+ pkgName);\n               pkgConfig.main = [];\n            }\n\n            pkgConfig.browser.main = (typeof pkgConfig.main === 'string') ? [pkgConfig.main] : pkgConfig.main;\n         }\n\n         /* if `pkgCaller` is set, then current loading package adress by `pkgName` is a dependency.\n          * therefore, it have to be added before the `pkgCaller` in the packages's configuration registry.\n          * else it's just a package to add in the considered registry.\n         */\n         if (pkgCaller) {\n\n            // mark package to be synchronously loaded and executed\n            pkgConfig.browser.async = false;\n            bower.package( pkgCaller ).browser.async = false;\n\n            if (bower.packageIndex( pkgCaller ) != -1) {\n\n               bower.packagesTree.splice( bower.packageIndex( pkgCaller ), 0, pkgConfig);\n            }\n         }\n         else {\n\n            bower.packagesTree.push( pkgConfig );\n         }\n\n         // if the current loading package have dependencies, then also process their loading\n         if (pkgConfig['dependencies']) {\n\n            var pkgDeps = Object.getOwnPropertyNames( pkgConfig['dependencies'] );\n\n            pkgDeps.forEach( function (name) {\n\n               bower.addPackage( name, pkgConfig['name']);\n            });\n         }\n      }\n\n      /**\n       * make sure that loadings packages's configuration process are ok with good dependencies organization,\n       * and proceed to packages importation *in the DOM* with correct order and associated behavior (callback, ...).\n       * @private\n      */\n      function checkReadyToImport() {\n\n         bower.loadingCount--;\n\n         // when all the loading package process are finished, process their importation on the DOM.\n         if (bower.loadingCount === 0) {\n\n            /* if all loading package's configuration process have failed, \n             * directly run globals callbacks (if they are).\n             * this, considering the fact that error can be check from callback by using the `status` argument.\n            */\n            if (bower.packagesTree.length === 0) {\n\n               bower.browser.loaded = true;\n               bower.ready();\n            }\n            else {\n\n               // be sure to have unique package occurence in package's tree\n               for (var i=0; i < bower.packagesTree.length; i++) {\n\n                  for (var j=i+1; j < bower.packagesTree.length; j++) {\n\n                     if (bower.packagesTree[i].name === bower.packagesTree[j].name) {\n\n                        bower.packagesTree.splice( j, 1);\n                        bower.total--;\n\n                        j--;\n                     }\n                  }\n               }\n\n               var pkgScriptTags = [],\n                   pkgLinkTags = [],\n                   isAlreadyLoaded = false,\n                   // Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n                   isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n                   loaderTag = undefined,\n                   domLoaderTags = undefined,\n                   devLinkTag = undefined,   // first custom link tag include by developer *in the document's <head>*\n                   devScriptTag = undefined, // first custom Script tag include by developer *in the document's <head>*\n                   getTag = undefined;       // supported tag\n\n               bower.packagesTree.forEach( function (pkg) {\n\n                  isAlreadyLoaded = false;\n                  /* before include a loader tag in the DOM, it's primordial to check if the associated file isn't already loaded in.\n                   * this assure to have an unique instance of a package in the DOM include by our `bower loader`.\n                  */\n                  if (document.querySelector) {\n                     // efficient : this is for all major browsers and IE>8\n                     if (document.head.querySelector('[data-bowerpkg =\"'+pkg.name+'\"]')) isAlreadyLoaded = true;\n                  }\n                  else { // alternative with more hack : this is specialy for IE<=8\n\n                     domLoaderTags = [].slice.call( document.head.getElementsByTagName('link') );\n                     domLoaderTags = domLoaderTags.concat( [].slice.call( document.head.getElementsByTagName('scrpit') ) );\n                     for (var j=0; j < domLoaderTags.length; j++) {\n\n                        if (domLoaderTags[j].getAttribute('data-bowerpkg') === pkg.name ) {\n\n                           isAlreadyLoaded = true;\n                           break;\n                        }\n                     }\n                  }\n\n                  if (!isAlreadyLoaded) {\n\n                     for (index in pkg.browser.main) {\n\n                        getTag = bower.parseTagType( pkg.browser.main[ index ] );\n\n                        if (getTag.name === 'script') { \n\n                           loaderTag = document.createElement('script');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.type = getTag.type;\n                           loaderTag.async = pkg.browser.async;\n\n                           /* with time, for other script support, paid attention to `load` event issue for some file by browsers.\n                            * look at comments below for `link` tag hack for more details.\n                           */\n                           bower.attachPackageCB( loaderTag, pkg.name );\n\n                           loaderTag.src = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgScriptTags.push( loaderTag );\n                        }\n                        if (getTag.name === 'link') {\n\n                           loaderTag = document.createElement('link');\n                           loaderTag.setAttribute('data-bowerpkg', pkg.name);\n                           loaderTag.rel = getTag.rel;\n                           loaderTag.type = getTag.type;\n\n                           /* browsers (as tested on firefox and chrome) seems to not execute event listeners \n                            * attached to `load` envent of some file (exception for css).\n                            * unless will find hack to resolve that, callbacks assignement will be directly checked\n                            * before considered files will have their path set to be included to the DOM.\n                           */\n                           if (getTag.fext !== \"css\") {\n\n                              console.warn(\"bowerder: can't attach callback to `onload` event of \"+ pkg.name +\"/\"+ pkg.browser.main[ index ]);\n                              bower.checkCallback( pkg.name );\n                           }\n                           else bower.attachPackageCB( loaderTag, pkg.name );\n\n                           loaderTag.href = bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ];\n\n                           pkgLinkTags.push( loaderTag );\n                        }  \n                        if (getTag.name === 'unknow') {\n\n                           // console.warn('bowerder: unable to load unsupported file: '+ bower.dir +'/'+ pkg.name +'/'+ pkg.browser.main[ index ]);\n                           // count the file for loading's fetching state \n                           bower.package( pkg.name ).browser.counter++;\n                        }                       \n                     }\n                  }\n               });\n\n               /* generally, developer use to include custom stylesheets or scripts,\n                * to overwrite library's properties or functions.\n                * this is done by including library first, before that custom hacks.\n                * therefore bowerder have to do the same to maintain that habit.\n                * loader can identify it imported packages with the `data-bowerpkg` attribute.\n                * it just to make sure to import them before non `data-bowerpkg` considered tag *in document <head>*.\n               */ \n               domLoaderTags = document.head.getElementsByTagName('link');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg') && domLoaderTags[i].rel && (domLoaderTags[i].rel !== 'icon')) {\n\n                     devLinkTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n               domLoaderTags = document.head.getElementsByTagName('script');\n               for (var i=0; i < domLoaderTags.length; i++) {\n\n                  if (!domLoaderTags[i].getAttribute('data-bowerpkg')) {\n\n                     devScriptTag = domLoaderTags[i];\n                     break;\n                  }\n               }\n\n               // Link tags importation process \"in the DOM\"\n               if (devLinkTag) {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devLinkTag );\n                  });\n               }\n               else {\n\n                  pkgLinkTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               // Script tags importation process \"in the DOM\"\n               if (devScriptTag) {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.insertBefore( loaderTag, devScriptTag );\n                  });\n               }\n               else {\n\n                  pkgScriptTags.forEach( function (loaderTag) {\n\n                     document.head.appendChild( loaderTag );\n                  });\n               }\n\n               if (bower.devMode) console.log( bower.packagesTree );\n            }\n         }\n      }\n   }\n};\n\n\n/**\n * import packages \"in the DOM\" with their dependecies \n * @param   {string}   pkgName  package's name\n * @param   {function} callback function to run after full package's importation\n*/\nbower.import = function (pkgName, callback) {\n\n   if (typeof pkgName !== 'string' && !(pkgName instanceof String)) {\n\n      console.error('bowerder:import: argument must be a string' );\n      return null;\n   }\n\n   if (callback) {\n\n      if (typeof callback !== 'function' && !(callback instanceof Function)) {\n\n         console.warn('bowerder:import: argument must be a function' );\n      }\n      else {\n\n         if (!bower.callbacks[ pkgName ]) bower.callbacks[ pkgName ] = [];\n\n         bower.callbacks[ pkgName ].push( callback );\n\n         /* with current import's process, callback which is added to the callbacks's registry have the last index.\n          * that index is keeped and will be use to access to that callback if necessary in certains conditions.\n          * loader will be able to import package when the bower components's local registry state will be determinate.\n         */\n         if (!(bower.components instanceof Object) && bower.components !== null) {\n\n            bower.browser.waitingImport.push( {name: pkgName, cbIndex: (bower.callbacks[ pkgName ].length - 1)} );\n         }\n         else bower.addPackage( pkgName, null, (bower.callbacks[ pkgName ].length - 1) );\n      }\n   }\n   else {\n\n      if (!(bower.components instanceof Object) && bower.components !== null) {\n\n         bower.browser.waitingImport.push( {name: pkgName, cbIndex: undefined} );\n      }\n      else bower.addPackage( pkgName );\n   } \n\n};\n\n\n/* first execution zone\n------------------------*/\n/* developer can manually include the bower components's local registry *in the DOM*.\n * if not, the bowerder have to try to include it by itself for better performence for loading process.\n*/\nif (bower.components === undefined) {\n   /* loader script have to be include *in the DOM* with the `data-bowerreg` attribute setting.\n    * that attribute will help to know which tag have to be use to automate local packages's registry loading.\n   */\n   if (document.querySelector) {\n      // efficient : this is for all major browsers and IE>8\n      bower.browser.loaderTag = document.querySelector('script[data-bowerreg]');\n   }\n   else { // alternative with more hack : this is specialy for IE<=8\n\n      var domScriptTags = document.getElementsByTagName('scrpit');\n\n      for (var j=0; j < domScriptTags.length; j++) {\n\n         if (domScriptTags[j].getAttribute('data-bowerreg')) {\n\n            bower.browser.loaderTag = domScriptTags[j];\n            break;\n         }\n      }\n   }\n\n   if (bower.browser.loaderTag) {\n\n      // assuming that loader path will usually be `path-to-bowerdir/bowerder/dist/loader.js`\n      bower.dir = bower.browser.loaderTag.src;\n      for (var i=0; i<3; i++) bower.dir = bower.dir.slice(0, bower.dir.lastIndexOf('/') );\n\n      bower.browser.regTag = document.createElement('script');\n      bower.browser.regTag.onload = function () {\n\n         if (!(bower.components instanceof Object)) {\n\n            bower.components = null; // will allow not already run import's function call to skip waiting import step\n            console.warn('bowerder: local registry isn\\'t found, loader will try to import package through Ajax API.');\n         }\n\n         bower.browser.waitingImport.forEach( function (pkgInfo) {\n\n            bower.addPackage( pkgInfo.name, null, pkgInfo.cbIndex );\n         });\n         bower.browser.waitingImport = [];\n      };\n      bower.browser.regTag.onreadystatechange = bower.browser.regTag.onerror = bower.browser.regTag.onload;\n\n      bower.browser.regTag.setAttribute('data-bowerpkg', '#bowerder');\n      bower.browser.regTag.src = bower.dir +'/.bowerreg.js';\n\n      document.head.appendChild( bower.browser.regTag );\n   }\n   else {\n\n      bower.components = null; // will allow not already run import's function call to skip waiting import step\n      console.warn('bowerder: seems that local registry isn\\'t provided; if so, loader will try to import package through Ajax API.');\n   }\n}"],"sourceRoot":"/source/"}